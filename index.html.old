<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		html, body{
			margin: 0;
			overflow: hidden;
		}
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
            integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
            crossorigin="anonymous" defer>
    </script>
</head>
<body>
	<canvas id="canvas"></canvas>

	<script type="x-shader/x-vertex" id="vs">
		attribute vec4 aVertexPosition;

		void main() {
			gl_Position = aVertexPosition;
		}
	</script>

	<script type="x-shader/x-fragment" id="fs">
		precision highp float;

		uniform vec2 uScreenSize;
		uniform vec2 uMouse;
		uniform vec4 uColor;
		uniform float uTime;
		
		void main(){
			gl_FragColor = vec4(gl_FragCoord.x/uScreenSize.x, gl_FragCoord.y/uScreenSize.y, uTime/1000.0, 1.0);
		}
	</script>

	<script>
		let c = document.getElementById('canvas');
		c.width = window.innerWidth;
		c.height = window.innerHeight;
		
		let gl = c.getContext('webgl');

		const vertexShader = loadShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').innerText);
		const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').innerText);

		// Create the shader program
		const shaderProgram = gl.createProgram();
		gl.attachShader(shaderProgram, vertexShader);
		gl.attachShader(shaderProgram, fragmentShader);
		gl.linkProgram(shaderProgram);

		// If creating the shader program failed, alert
		if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
			alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
		}

		// get memory locations in the shader program
		aVertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');
		uScreenSize = gl.getUniformLocation(shaderProgram, "uScreenSize")
		uColor = gl.getUniformLocation(shaderProgram, 'uColor');
		uTime = gl.getUniformLocation(shaderProgram, 'uTime');
		uMouse = gl.getUniformLocation(shaderProgram, 'uMouse');

		// create vertexuffer
		const vertexData = new Float32Array([
			-1, -1, 0,
			-1, 1, 0,
			1, -1, 0,
//			1, 1, 0,
		]);

		const buffer = gl.createBuffer();
		gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
		gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
		gl.vertexAttribPointer(
			aVertexPosition,
			3, // num components
			gl.FLOAT, // data type
			false, // normalized
			0, // strinde
			0 // offste
		);
		gl.enableVertexAttribArray(aVertexPosition);

		function tick(t){
			//console.log(t);
			render(t);
			window.requestAnimationFrame((t) => tick(t));
		}

		let mouseX = 0;
		let mouseY = 0;

		window.addEventListener("mousemove", (e) => {
			mouseX = e.clientX;
			mouseY = e.clientY;

		})

		
		function render(t){
			// Clear the canvas before we start drawing on it.
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clearDepth(1.0);
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	
			gl.useProgram(shaderProgram);
	
			gl.uniform2f(uScreenSize, c.width, c.height);
			gl.uniform2f(uMouse, mouseX, mouseY);
			gl.uniform4f(uColor, 0, 0, 0, 1);
			gl.uniform1f(uTime, t);
	
			vertexData[0] = t/10000;

			//gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			//gl.bufferSubData(gl.ARRAY_BUFFER, 0, new Float32Array([0]));
	
			gl.drawArrays(gl.TRIANGLES, 0, 3);

		}


		function loadShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return null;
			}

			return shader;
		}

		window.onload = tick;
	</script>
</body>
</html>