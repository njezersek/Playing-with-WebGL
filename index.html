<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Document</title>
	<style>
		html, body{
			margin: 0;
			overflow: hidden;
		}
	</style>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"
            integrity="sha512-zhHQR0/H5SEBL3Wn6yYSaTTZej12z0hVZKOv3TwCUXT1z5qeqGcXJLLrbERYRScEDDpYIJhPC1fk31gqR783iQ=="
            crossorigin="anonymous" defer>
    </script>
</head>
<body>
	<canvas id="canvas"></canvas>

	<script type="x-shader/x-vertex" id="vs">
		attribute vec4 aVertexPosition;

		void main() {
			gl_Position = aVertexPosition;
		}
	</script>

	<script type="x-shader/x-fragment" id="fs">
		precision highp float;

		uniform vec2 uScreenSize;
		uniform vec4 uColor;
		
		void main(){
			gl_FragColor = vec4(gl_FragCoord.x/uScreenSize.x, gl_FragCoord.y/uScreenSize.y, uColor.x, 1.0);
		}
	</script>

	<script>
		function main(){
			let c = document.getElementById('canvas');
			c.width = window.innerWidth;
			c.height = window.innerHeight;
			
			let gl = c.getContext('webgl');

			const vertexShader = loadShader(gl, gl.VERTEX_SHADER, document.getElementById('vs').innerText);
			const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fs').innerText);

			// Create the shader program
			const shaderProgram = gl.createProgram();
			gl.attachShader(shaderProgram, vertexShader);
			gl.attachShader(shaderProgram, fragmentShader);
			gl.linkProgram(shaderProgram);

			// If creating the shader program failed, alert
			if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
				alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
				return null;
			}

			aVertexPosition = gl.getAttribLocation(shaderProgram, 'aVertexPosition');

			uScreenSize = gl.getUniformLocation(shaderProgram, "uScreenSize")
			uColor = gl.getUniformLocation(shaderProgram, 'uColor');

			console.log(uScreenSize, uColor, aVertexPosition);

			const vertexData = new Float32Array([
				-1, -1,
				-1, 1,
				1, -1,
				1, 1,
			]);

			const buffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
			gl.bufferData(gl.ARRAY_BUFFER, vertexData, gl.STATIC_DRAW);
			gl.vertexAttribPointer(
				aVertexPosition,
				2, // num components
				gl.FLOAT, // data type
				false, // normalized
				0, // strinde
				0 // offste
			);
			gl.enableVertexAttribArray(aVertexPosition);

			// Clear the canvas before we start drawing on it.
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			gl.clearDepth(1.0);
			gl.enable(gl.DEPTH_TEST);
			gl.depthFunc(gl.LEQUAL);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			gl.useProgram(shaderProgram);
			
			gl.uniform2f(uScreenSize, c.width, c.height);
			gl.uniform4f(uColor, 0, 0, 0, 1);


			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
		}


		function loadShader(gl, type, source) {
			const shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);

			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
				gl.deleteShader(shader);
				return null;
			}

			return shader;
		}

		window.onload = main;
	</script>
</body>
</html>